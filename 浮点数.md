浮点数
=========

浮点数其实是很简单的。数就是一个数字，一个有理数；而浮点，表示的是一种编码方案，将有理数编码存放在字节中的格式。这种编码方案是有标准的，即[IEEE标准754](https://zh.wikipedia.org/wiki/IEEE_754)。

#### 定点数
与浮点相对应的是定点数，它更简单，我们先来看看。

 ![](images/浮点数-01.png)
 上面这幅图展示了定点数在二进制下的表示，图很简单易懂也不需要过多的说明，整个数值b最终为：
$ b = \sum_{i=-n}^m i^2 \times b_i $

比如，$101.11_2$表示数字：
$ 1\times2^2 + 0\times2^1 + 1\times2^0 + 1\times2^{-1} + 1\times2^{-2} $
$ = 4 + 0 + 1 + \frac{1}{2} + \frac{1}{4} $
$ = 5\frac{3}{4} $

定点数的缺点在于没有**变化量**。小数点位置确定了之后，取值范围也就定了下来。相对于浮点来说，其可表示的范围是比较窄小的：
- 表示一个很大的数，比如$ 5 \times 2^{100} $这将是在101的后面再放上100个0（位模式），定点考虑成本的情况下根本不可能完成
- 表示很小的数时，绝大部分二进制位都将是0，浪费比较严重，精度相当低；

浮点数引入了变化量，即它的阶码。用阶码来乘上尾数部分，相当于小数点左右移动若干位，由此得名浮点数。

#### IEEE浮点数
IEEE浮点标准用$ V = (-1) ^ s \times M \times 2 ^E $的形式来表示一个数：
- 符号
 一个单独的符号位单独编码s，s决定了该数是一个正数（s=1）还是负数（s=0）
- 尾数
 尾数M（frac，n位）是一个二进制小数，单精度编码下有23位，双精度编码下有52位：
 $ frac = f_{n-1}...f_1f_0 $
- 阶码
 阶码E（exp，k位）的作用是对浮点数加权，权重是$ 2^E $，单精度编码下有8位，双精度编码下有11位：
 $ exp = e_{k-1}...e_1e_0 $

下图是上述描述的图例展示：
![](images/浮点数-02.png)

根据exp的值，被编码的值可以分成三种情况，第三种情况又有两个变种：
![](images/浮点数-03.png)

我们分别来看看：
- 第一种情况规格化的值是最普遍的情况。当exp的位值不全为0也不全为1时就属于这种规格化的情况。此时，简单的记住：
$ E = e - Bias $
其中，e是无符号数（节约一个符号位咯，能省则省嘛），位表示为$ e_{k-1}...e_1e_0 $；而Bias定义为=$ 2^{k-1} - 1 $，由此E的取值，单精度格式下是-126 ~ 127，双精度格式下是-1022 ~ 1023
M被定义为$ 1 + f $（这多出来的1是向阶码借来的），而f的二进制表示为$ 0.f_{n-1}...f_1f_0 $，因此M被表达为了$ 1.f_{n-1}f_{n-2}...f_0 $，我们因此而多获得了一个精度位！
- 第二种情况阶码域全为0，此时所表示的数是非规格化形式的。在这种情况下：
$ E = 1 - Bias $，而尾数$ M = f $，阶码全为0是借不来那个1的了。
你可能会好奇为什么会有非规格化形式的存在，它的存在解决了两个问题：
    - 提供了一个表示数值0的方法；在规格化的情况中，总是有$ 1 \leq M \lt 2 $，因此无论如何我们是表示不了0这个值的
    - 因为已经可以表示0了，所以0到1之间这一段的数也是能够表示的了
- 第三种情况就是用来表达各种特殊值的，此时阶码域全为1：
    - 当小数域全为0，整个值根据s的取值可以是$ +\infty $或者$ -\infty $
    - 当小数域非0时，结果值被成为NaN（Not a Number）

#### 精度
以单精度为例，其尾数部分有23位再加上左手边没有存储的第一个位，总共24位，因此其能表达的最大十进制数的位数大概有：
$ \log2^{24} \approx 7.22 $
顺便双精度是：
$ \log2^{53} \approx 15.95 $
需要说明的是指数部分$ 2^E $相乘并不会影响实际的精度（只是给尾数加权而已），精度这里只取决于尾数部分。
我们来看看单精度表示下尾数部分最小的数是多少：
$ 2^{-23} = 0.00000011920928955078125 $
考虑到上面计算出来的单精度能表示十进制最多7位，因此这里尾数部分最小能表示的数也就是0.0000001了。丢失精度大致可以分为两种情况：
- 有效数字超过最大长度
  比如对于1310720000000000000000.66这个数，其有效数字有24位，早早的超过了单精度能表示的有效数字范围，双精度也超过了。
  ```csharp
  var s_float = DoubleConverter.ToExactString(1310720000000000000000.66f);
  var s_double = DoubleConverter.ToExactString(1310720000000000000000.66d);
  ```
  结果并不意外，s_float：1310720035725537968128，s_double：1310720000000000000000；在float的表示中我们的误差接近35万亿！
- 进制缺陷导致无法表达某些数
  原因很简单。比如单精度，尾数部分总共就23bit可用，而有些十进制小数转换到二进制下会出现无限循环的情况（就像十进制下1/3无限循环一样）。来看看0.09这个数：
  ```csharp
  var s_float = DoubleConverter.ToExactString(0.09f);
  ```
  结果也不意外，s_float：0.0900000035762786865234375；

#### C#中的浮点数
c#中的小数类型就三种，`float`、`double`以及`decimal`。

前面两个遵循上面所描述的关于浮点数的编码规则。实际工作中因为浮点的特性带来的一些问题，我们尤其需要注意，比如：
- 比较两个浮点数的大小
 如果是大于或者小于比较是没有太大问题的；但若是判等，由于精度的误差就可能产生意外的结果。一种比较常见的解决办法是，去这两个要比较的数相减后值的绝对值，然后判定该值是否落在一个业务规定的误差范围内。是，则说明两个数近似相等，否则不等；

而decimal类型，在c#中是很特殊的。首先，它仍然是一个浮点类型（所以仍然会受到精度问题的困扰），其次它的进制是10进制，而不是float、double那种的2进制！

10进制意味着什么？意味着，我们实际在程序代码中键入的数字都会被准确的录入到decimal类型中！

基本的浮点编码对于decimal而言，符号位仍然是1位，指数部分有5bit可以用（但是实际有效的值只能是0~28），剩下尾数部分有96位可用：
$ V = (-1) ^ s \times M \div 10 ^E $
如此一来十进制下可以表达的最大位数大约就是：
$ \log2^{96} \approx 28.89 $

#### 数据库中的浮点数

参考链接：
https://zh.wikipedia.org/wiki/IEEE_754
https://stackoverflow.com/questions/19601975/storing-statistical-data-do-i-need-decimal-float-or-double
https://csharpindepth.com/Articles/FloatingPoint
https://csharpindepth.com/Articles/Decimal
https://blog.csdn.net/renwotao2009/article/details/51637163
https://www.zhihu.com/question/36666686
https://www.cnblogs.com/xsj1989/p/7058628.html